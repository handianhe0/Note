C++面试问题
C++基础       
• 指针和引用的区别        指向改变、初始化、++、sizeof
• 堆和栈的区别        释放方式、存储内容、
• new和delete是如何实现的，new 与 malloc的异同处        位置、分配方式、返回值
• C和C++的区别
• C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）        
• Struct和class的区别        strutc公有继承、class私有继承
• define 和const的区别（编译阶段、安全性、内存占用等）        define预编译是替换&多份拷贝、const只有一份拷贝、const有数据类型
• 在C++中const和static的用法（定义，用途）        都不能在类内初始化、const设置只读（不可修改）、static限定作用域（模块内、模块内可调用）
 class Test  
 {  
 public:  
       Test():a(0){}  
       enum {size1=100,size2=200};  
 private:  
       const int a;//只能在构造函数初始化列表中初始化  
       static int b;//在类的实现文件中定义并初始化  
       const static int c;//与 static const int c;相同。  
 };  
   
 int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。  
 cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符。但要加cosnt  
• const和static在类中使用的注意事项（定义、初始化和使用）        
• C++中的const类成员函数（用法和意义），以及和非const成员函数的区别        类的成员函数后面加const表明不会对这个类对象的数据成员作任何改变。
• C++的顶层const和底层const        
    int i = 0;
    int *const p1 = &i     //不能改变p1指针存的地址，顶层const
    const int ci = 42;    //常量不能改变，也算是顶层const
    const int *p2 = &ci;    //p2存的地址可以改变，但p2解引用后得到const int，不能改变，底层const
    const int *const p3 = p2;    //分析p3类型，*const说明是顶层const，const int说明是底层const
    p2 = p3;
• final和override关键字        final可以禁用继承和重写、override可以检测是否重写
• 拷贝初始化和直接初始化，初始化和赋值的区别          就是拷贝构造和直接调用构造函数|初始化发生在编译时、幅值发生在运行时
• extern "C"的用法        用于c++与C混编
• 模板函数和模板类的特例化        template<class T>class Test{ ->  template<>class Test<int>{
• C++的STL源码（这个系列也很重要，建议侯捷老师的STL源码剖析书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）        
• STL源码中的hashtable的实现        对key做hash，hash值做为存放在一个数组里的地址（ 使用名为hash faction的散列函数来定义有名项与存储地址之间的映射关系），当数组里的元素发生冲突时，在冲突处使用拉链法
• STL中unordered_map和map的区别和应用场景        Map的key唯一，set的值唯一
• STL中vector的实现        
• STL容器的几种迭代器以及对应的容器（输入迭代器once，输出迭代器once，前向迭代器forward_list，双向迭代器，随机访问迭代器）        
• STL中的traits技法        萃取机
• vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。        空间不足需要扩容，扩容过程中涉及旧数组向新数组的拷贝
• C++中的重载和重写的区别        编译时多态、运行时多态
• C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解        
• 介绍面向对象的三大特性，并且举例说明每一个        封装：private  多态：虚函数  继承：父子
• C++多态的实现            虚函数、虚函数表
• C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，因为调用的时候会传this指针，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间：对象创建时初始化，对象创建完成时确定指向，因为子类对象创建时先调用父类构造函数，虚指针指向父类虚表）        虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。
• C++中类的数据成员和成员函数内存分布情况        成员变量属于对象，成员函数属于类   成员函数和全局函数一样，只是在编译时传入了对象的指针
• this指针        对象的地址
• 析构函数一般写成虚函数的原因        创建指针对象后，delete释放资源，可以既调用子类析构，又调用父类析构
• 构造函数、拷贝构造函数和赋值操作符的区别           拷贝构造是对象还未创建时调用，对象已创建之后再给对象传值调用的是'='运算符
• 构造函数声明为explicit        explicit关键字的作用就是防止类构造函数的隐式自动转换 如classname obj = 10；在没有explicit时是通过隐式转换调用有参构造创建的
• 构造函数为什么一般不定义为虚函数        因为是没有意义的，虚函数是为了实现多态，而构造函数不能直接调用，因此没必要实现多态  虚函数始终仅仅调用基类的虚函数
• 构造函数的几种关键字(default delete 0)        default表示使用默认构造函数，delete相反，0是用于声明纯虚函数的
• 构造函数或者析构函数中调用虚函数会怎样        因为构造派生类要先调用基类构造，基类构造中调用虚函数体现出的是基类特性，与多态性不符（语法上没有错） 创建子类对象时，先调父类构造，父类构造调用虚函数是父类的虚函数，只有普通成员函数调用虚函数能够实现多态
• 纯虚函数        virtual void funtion()=0;
• 静态类型和动态类型，静态绑定和动态绑定的介绍       静态类型就是父类指针类型，动态类型是指父类指针指向的子类对象的类型
表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；
而动态类型则是变量或者表达式表示的内存中的对象的类型，动态类型直到运行时才可知。
• 引用是否能实现动态绑定，为什么引用可以实现        引用不能改变指向，因此无法实现多态
• 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）        浅：两个对象指向同一地址；深：指向不同地址  默认拷贝函数是浅拷贝，析构时两次析构，会有内存泄露
• 对象复用的了解，零拷贝的了解        对象复用（对象池）
• 介绍C++所有的构造函数        默认构造函数、一般构造函数、拷贝构造函数
• 什么情况下会调用拷贝构造函数（三种情况）        classname newobj(obj);  classname newobj  = obj;  classname newobj=fun();这里fun()返回值为一个对象
• 结构体内存对齐方式和为什么要进行内存对齐？        对齐方式与变量的顺序有关，前一大于后一时直接加，后一大于前N时，相加并扩为后一的整数倍  原因：设备原因（不是说有设备都能访问所有内存）效率原因（未对齐的内存需要访问两次）
• 内存泄露的定义，如何检测与避免？        程序未能释放掉不再使用的内存的情况  使用BoundChecker或valgrind检测，使用智能指针来避免
• 手写智能指针的实现（shared_ptr和weak_ptr实现的区别）        
• 智能指针的循环引用        导致内存泄漏，通过将任一shared_ptr改为weak_ptr即可解决
• 遇到coredump要怎么调试        gdb [exec file] [corefile]
• 内存检查工具的了解        valgrind
• 模板的用法与适用场景        
• 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？        少了一次调用默认构造函数的过程
• 用过C++ 11吗，知道C++ 11哪些新特性？        迭代器、auto、nullptr、智能指针、委托构造、继承构造、Lambda表达式、强制类型转换
• C++的调用惯例（简单一点C++函数调用的压栈过程）        main函数入栈，位于栈底，遇到函数再将函数入栈，函数运行结束，函数出栈，main结束，main出栈
• C++的四种强制转换        1、static_cast没有运行时类型检查来保证转换的安全性，2、const_cast能将 const int* 转成 int*，3、reinterpret_cast可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针，4、dynamic_cast运行时处理的，运行时要进行类型检查
• C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）        
• C++的异常处理        try{}catch(...){}   throw
• volatile关键字        遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问
• 优化程序的几种方法        掌握常用的高效的数据结构和算法\尽量减少循环次数\消除不必要的存储器引用\提高并行性\多线程编程
• public，protected和private访问权限和继承        
private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问

public继承：public继承后，从父类继承来的函数属性不变（private、public、protected属性不变，）。
private继承：private继承后，从父类继承来的函数属性都变为private
protected继承：protected继承后，从父类继承过来的函数，public、protected属性变为protected，private还是private
• class和struct的区别        strut公有继承、class私有继承
• decltype()和auto        decltype()推导类型并定义 int a; decltype(a) x;定义了a同类型的x 
• inline和宏定义的区别        
（1）内联函数在编译时展开，宏在预编译时展开；
（2）内联函数直接嵌入到目标代码中，宏是简单的做文本替换；
（3）内联函数有类型检测、语法判断等功能，而宏没有；
（4）inline函数是函数，宏不是；
（5）宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；
• C++和C的类型安全
（1）操作符new返回的指针类型严格与对象匹配，而不是void*；
（2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
（3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
（4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
（5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。



操作系统基础        
• 进程与线程的区别和联系        资源分配，CPU调度；堆，栈；一个进程包含多个线程；数据共享难、易；资源消耗多、少；线程在执行过程中，需要协作同步
• 一个进程可以创建多少线程，和什么有关        和用户可以使用的内存大小和线程所占内存(1M)有关
• 一个程序从开始运行到结束的完整过程（四个过程）        预处理（.i，头文件编译进来，宏替换），编译（.s，各种分析后汇编语言），汇编（.o），链接（模块间，动态 静态）
• 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）        
Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字（socket）
Linux线程间通信：互斥量（mutex）,信号量，条件变量
Windows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字（socket）
Windowst线程间通信：互斥量（mutex）,信号量（semaphore）、临界区（critical section）、事件（event）
• 文件读写使用的系统调用        open，close，creat，read，write
• 怎么回收线程        
linux线程执行，pthread有两种状态joinable状态和unjoinable状态
线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当调用了pthread_join之后这些资源才会被释放。
若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。
• 守护进程、僵尸进程和孤儿进程        守（独立与控制终端的程序）僵（子进程结束但父进程未调用wait|waitid导致子进程信息不被释放）孤（子进程的父进程结束，子被Init进程收留）
• 处理僵尸进程的两种经典方法        父进程回收法（父进程调用wait方法使父进程阻塞直到子进程结束运行）init进程回收法（init的子进程结束会自动回收其子进程）
• 进程终止的几种方式        正常退出（调用return、_exit、exit）、异常退出（调用abort退出、外部信号强制退出ctrl+c）
• linux中异常和中断的区别        中断是由硬件产生的，交由CPU处理，CPU交由内核处理；异常由CPU产生，交由内核处理；     使用不同的处理程序
• 一般情况下在Linux/windows平台下栈空间的大小        L8M W1M
• 五种IO模型         阻塞、非阻塞、信号驱动、多路复用、异步
• 程序从堆中动态分配内存时，虚拟内存上怎么操作的        
• 交换空间与虚拟内存的关系        Linux系统只有内存不够用的时候才使用交换空间，windows在任何时候都可能会用到虚拟内存，交是独立的空间，虚可放在任意盘符下，默认C盘
• 堆和栈的区别；从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）        栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快
• 内存泄漏和内存溢出        泄漏：程序结束时无法释放内存   溢出：剩余的内存不够申请
• 常见内存分配方式和错误        静态存储区分配、栈区分配、堆区分配     问题：未分配就使用、未初始化就引用、忘记释放、释放后还使用、数组越界
• 堆内存和栈内存的区别        分配释放方式、存储的内容
• 可重入函数和可重入内核        可重入函数是指在任何时候都可以中断并转而去执行其他任务，返回后没有问题； 内核都是可重入的
• 操作系统动态内存分配的几种策略        首次适应法（最快）、最佳适应法（碎片最小）、最差适应法
• 内部碎片和外部碎片        
为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。
为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。
• 系统调用进入内核态的过程        应用程序调用系统调用API，存入系统调用号，出发0x80中断，进入中断服务程序，根据调用号调用系统调用 返回 中服 返回 API 返回 应用程序
• 内核态和用户态的区别        内核态位于0级特权环（R0），可以访问所有的内存空间和对象，所占用的处理器不能被抢占；用户态位于3级特权环（R3），进程可以访问的内存空间和对象受限，处理器可以被抢占
• 常见的进程调度算法以及linux的进程调度       时间片轮转、先来先服务、短作业优先、最高相应比优先、优先级调度、多级反馈调度
• 中断、陷阱、故障和终止         中：硬件导致、异步   陷阱：执行语句的结果、同步异常   故障：错误引起，若被修正则正常执行，否则abort()   终止：知名错误、直接abort()
• 线程互斥和同步的方法        互斥变量(互斥锁)、信号量、条件变量、读写锁
• 内存对齐的规则和作用        对齐方式与变量的顺序有关，前一大于后一时直接加，后一大于前N时，相加并扩为后一的整数倍  原因：设备原因（不是说有设备都能访问所有内存）效率原因（未对齐的内存需要访问两次）
• 页面置换算法        最佳置换（OPT）算法、先进先出置换（FIFO）算法、最近最久未使用（LRU）算法
• 实现一个LRU页置换算法（或者FIFO置换算法）        
• 死锁的必要条件（怎么检测死锁，解决死锁问题）,银行家算法（死锁避免）        循环等待、不可剥夺、请求与保持、互斥
• 哲学家就餐，读者写者，生产者消费者（怎么加锁解锁，伪代码）        
• 海量数据的bitmap使用原理        redis bitmap setbit getbit...
• 布隆过滤器原理与优点        使用几个hash函数对数据进行映射，最后通过对需要查询的数据进行hash来看map是否置1来确定一定不存在和可能存在
• 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题



网络基础        
• 网络的几种分层体系结构        OSI（应、表、会、传、网、数、物）TCP\IP(应、传、网、网接)  五层（应、传、网、数、物）
• 建立TCP服务器的各个系统调用        socket() bind() listen() connect() accept() send() recv() shutdown()
• socket网络编程close是一次就能直接关闭的吗，半关闭状态是怎么产生的？        由于可能有很多连接，因此只是引用计数减一而不是直接关闭；半关闭状态是client发送FIN后需要server的ACK，此时只能接收不能发送
• MTU和MSS        
MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。
MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。
• 对路由协议的了解与介绍        
• 路由协议所使用的算法        RIP，OSPF，BGP
• 路由表的项目包括哪些        前缀、掩码、下一跳、开销、优先级、输出接口
• 地址解析协议ARP的过程        主机广播arp询问ip为。。是谁，从收到arp返mac地址，主机ping从机，从机收到icmp广播arp询问主机的mac
• 网际控制报文协议ICMP的过程        
• 动态主机配置协议DHCP的过程        
• WAN LAN WLAN VLAN VPN的区别        
• 介绍一下VPN（虚拟专用网）        
• TCP和UDP的区别        TCP 流、可靠、头部20、面向连接、开销大、拥塞控制流量控制   UDP 数据报、不可靠、头部8、无连接、开销小、无拥塞流量控制
• TCP如何保证数据的正确性        通过循环冗余校验CRC校验数据
• TCP和UDP相关的协议与端口号        TCP(http80\https443\smtp25)   UDP(DNS53\DHCP67)
• TCP（UDP，IP）等首部的认识（http请求报文构成）        请求行（请求方法、URL、协议版本）、请求头、请求体
• 网络层分片的原因与具体实现        因为链路层的最大传输单元MTU限制了传输数据的大小
• TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）        
• TCP握手以及每一次握手客户端和服务器端处于哪个状态（11种状态）        SYN_SEND SYN_RECV ESTABLISHED FIN_WAIT1 FIN_WAIT2 CLOSE_WAIT LAST_ACK TIME_WAIT 
• 为什么使用三次握手，两次握手可不可以？        两次握手可能导致服务端收到过期的客户端请求，从而占用资源等待客户端发送数据
• TIME_WAIT的意义（为什么要等于2MSL）        防止客户端ACK未到达服务端，服务端可以重发FIN；防止过时的ACK到达服务端；MSL是最大存活时间，FIN+ACK为2MSL
• 超时重传机制（不太高频）        发送后定时，未收到ACK重传
• TCP怎么保证可靠性（面向字节流，超时重传，应答机制，滑动窗口，拥塞控制，校验等）？        
• 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？        
• TCP滑动窗口协议        窗口包含（已发未收ACK，已读如内存未发送）
• 拥塞控制和流量控制的区别        拥控是为了防止过多数据注入网络使网络中的路由器或链路不致过载；流控是解决发送接收不同步的问题
• TCP拥塞控制，算法名字？（极其重要）        慢启动、拥塞避免、快速恢复、快速重传
• 网页解析的过程与实现方法        
• 应用层协议常用的端口号        http80 https443 ssh22 telnet23 smtp25 dns53 ftp20\21
• http协议与TCP联系        http是应用层协议，定义的是传输数据的内容规范；TCP是传输层协议，定义的是传输数据和建立连接的规范；HTTP是使用TCP进行数据传输的
• http/1.0和http/1.1的区别        1.0不默认长连接
• http的请求方法有哪些？get和post的区别。        get请求资源 post上传或更新资源
• http的状态码        200OK 400请求语句错误、403拒绝服务、404找不到资源、500服务器错误、503一段时间后恢复服务
• http和https的区别，由http升级为https需要做哪些操作        http安装SSL证书后就成了https
• https的具体实现，怎么确保安全性        
• 在浏览器输入一个URL的流程，这个过程中浏览器做了什么（如www.baidu.com）        
• URL包括哪三个部分？        协议、ip、文件路径
• 长连接与短连接的区别以及使用场景        长连接是在server响应之后不断开连接，用于操作频繁、点对点通信；短连接一般用于WEB的http服务
• 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？        65535，不可改变
• 介绍一下ping的过程，分别用到了哪些协议        IP封装ICMP包，使用ARP查找目标mac地址，发送ICMP包，目标收到返回ICMP包
• 对称密码和非对称密码体系        对称：相同的密钥加密解密；非对称：不同的密钥加密和解密
• 数字证书的了解（高频）        证书可以确保证书里的公钥确实是证书所有者的，证书内包含（颁发机构、公钥、有效期、签名算法、持有者）
• 客户端为什么信任第三方证书        因为通常第三方证书的颁发机构是足够权威的，所提供的根证书已经添加进了证书列表里
• RSA加密算法（非对称加密，用公匙和私匙实现）;        RSA是基于大数很难做质因子分解而进行的非对称加密
• MD5原理（MD5是密码散列函数）=> SHA安全散列算法替代        MD5将明文内容按某种规则生成一段hash值，只要明文内容稍有改变，hash值都会完全不同
• 单条记录高并发访问的优化        
• 数据流和粘包问题        
• 一台机器最多可以建立多少tcp连接？         180000
• 五种IO模型的过程和比较        阻塞、非阻塞、信号驱动、多路复用、异步
• IO多路复用（select，poll，epoll的区别）        
select    轮询    fd_set    需要每次将fd拷贝进内存     少量fd且活跃    fd最多1024
poll      轮询    fd链表    需要每次将fd拷贝进内存     少量fd且活跃    fd无限制
epoll     信号    fd_ctl    共享内存                  大量fd不活跃    fd无限制
• 有没有抓过TCP包，描述一下        wireshark选网卡，过滤TCP
• 一个ip配置多个域名，靠什么识别？        端口
• 服务器攻击（DDos攻击）        
• 重放攻击，IP欺骗                 Linux相关        
• Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）        
• 文件系统的理解（EXT4，XFS，BTRFS）        
• 文件处理grep,awk,sed这三个命令必知必会        
• IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？        
• Epoll的ET模式和LT模式（ET的非阻塞）        LT水平触发（默认）通知的事件未处理下次还会通知；ET边缘触发，通知的事件不处理，直接移除等待队列，下次自然不在通知；ET效率更高
• 查询进程占用CPU的命令（注意要了解到used，buf，***代表意义）        
• linux的其他常见命令（kill，find，cp等等）        
• shell脚本用法        
• 硬连接和软连接的区别
硬链接：两个文件指向同一磁盘空间  ln file1 file2  给file1创建硬链接
软连接：文件2指向文件1，文件1指向磁盘空间，类似快捷方式 ln -s file1 file2
• 文件权限怎么看（rwx）        ll显示当前目录的详细信息
• 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变        atime只要访问就改变  ctime只要修改里面的内容就改变  mtime修改文件属性（权限之类）就会改变
• Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令   ifstat  nethogs




数据库基础        
• 关系型和非关系型数据库的区别（各自优点）        关系型技术成熟，只支持基本数据类的查询，数据存放在硬盘上，查询速度慢，收费            非关系型技术较新，学习资料少，数据存放在缓存中，查询速度快，开源
• 常用SQL语句（DDL,DML,DCL,TCL）        
• 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写        
• 数据库的索引类型        普通索引、唯一索引、主键索引、复合索引、全文索引
• 聚集索引和非聚集索引的区别（叶节点存储内容）        
像InnoDB这种将索引和数据存放在一起（一个.ibd文件中）的主键索引就是聚集索引        InnoDB叶子节点存储的是数据
像MyISAM这种将索引和数据分开存放（.MYI和.MYD）的主键索引就是非聚集索引           MyISAM叶子节点存储的是索引
• 唯一性索引和主码索引的区别        主键索引是一种特殊的唯一索引，一个表只有一个主键，一般在建表时创建主键索引
• 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）        
1. 优点：
    通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。
    可以加快数据的检索速度
    可以加速表与表之间的连接
    在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间
2. 缺点
    创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
    索引需要占用物理空间，数据量越大，占用空间越大
    会降低表的增删改的效率，因为每次增删改索引，都需要进行动态维护
3. 什么时候需要创建索引
    * 主键自动建立唯一索引
    * 频繁作为查询条件的字段应该创建索引
    * 查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找
    * 查询中统计或者分组的字段；
• 索引的底层实现（B+树，为何不采用红黑树，B树）        
• B树和B+树具体实现        B数在每个节点下面都存数据 B+树只有叶子节点下面存放数据
• 索引最左前缀问题        如果在a、b、c列上建立了组合索引，使用索引进行查询时，a|a,b|a,b,c 这3种情况是会用到每一列的索引的，而b,c|c是不会用到索引的，这就是最左前缀原则，此外如果是a,c只有a会用到索引
• Mysql的优化（高频，索引优化，性能优化）        
• 数据库引擎介绍，Innodb和Myisam的特点与区别        Innodb为聚合索引，查询效率高于Myisam非聚合索引；InnoDB支持事务，MyISAM不支持；InnoDB支持外键，而MyISAM不支持
• 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）        ACID原子、一致、隔离、持久
• 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）        不可：updata+commit 幻读：insert+commit 丢失修该:A=100,事务1A-30,事务2A=10，结果是90，也就是事务2的操作使事务1的值丢失
• 数据库的隔离级别，Mysql和Oracle的隔离级别分别是什么        RU读未提交 RC读已提交 RR可重复读 Serializable可串行化
• 数据库连接池的作用        用户房访问网站的数据库需要建立连接，用完后释放；但是当有很多用户访问时，效率降低，因此，在用户访问数据库前，创建连接池提前准备好连接，不同用户访问数据库直接从连接池获取连接，用完还给连接池
• Mysql的表空间方式，各自特点        独立表空间、共享表空间   独立：每个表有自己的表空间、数据索引放在自己的表空间内、可以实现数据库间的移动     共享：可以将表空间拆分为多个文件存放在磁盘上
• 分布式事务        
• 数据库的范式        一范式，看是否满足原子性，满足则是（一个字段下不能有其它字段） 二范式看是否存在部分函数依赖，存在则不是（如果存在重复字段却能用一个字段来确定）  三范式看是否存在传递函数依赖（A->B,B->C则A->C）
• 数据的锁的种类，加锁的方式       
共享锁(Shared lock)    A和B可以对同一资源加共享锁，且都可以读，但不能写，任意一方想加排他锁，必须等另一方释放该锁
排它锁(Exclusive Locks)    A和B任一方加排他锁，另一方都不能再对该资源加锁
临键锁(Next-Key Locks)    RR可以理解为一种特殊的间隙锁，也只能对非唯一索引加锁，锁住的是当前键开始到下一键值的左开右闭区间，加锁后其他事务无法在这个区间插入数据，解决了幻读问题
间隙锁(Gap Locks)    RR只能对非唯一索引加锁，条件里有范围，另外需要确保执行该语句时，explain种确实走了索引
自增锁(Auto-inc Locks)    表级别锁，专门针对事务插入AUTO_INCREMENT类型的列。如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行是连续的主键值。
计划锁(Schema Locks)    该锁不允许任何其它session连接该表。连都连不了这个表了，当然更不用说想对该表执行什么sql语句了
意向锁(Intent Locks)    表级锁，当表内有资源加锁，不需要访问表内去看，直接看是否加了表锁
更新锁(Update lock)    为了解决死锁，引入了更新锁，当A加了更新锁，B就不能加锁并阻塞，当其他用户尝试加锁并不会阻塞而是直接返回“我现在只想读，你们别人也可以读，但我将来可能会做更新操作，我已经获取了从共享锁（用来读）到排他锁（用来更新）的资格”
• 事务：单一逻辑工作单元的集合
• 视图的作用与使用方法（如何删除等）        视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。creat view v_t as select * from table1 where id>1 and id<5;
• 分库分表，主从复制，读写分离。（我不会，也没碰到过）        
• 项目中哪里用到了数据库，怎么用的        
• Mem***和Redis了解




大数据和分布式        
• Hadoop框架下，各个组件的构成及作用        
• BASE原则，CAP原则        
• 一致性算法Raft的过程        
• TIDB原理        
• HBase的存储原理        
• HDFS运行原理        
• Hive的了解        
• Spark的了解        
• 介绍熟悉的设计模式（单例，简单工厂，观察者模式等等）        
• 写单例模式（饿汉模式和懒汉模式），线程安全版本        
• MVC设计模式