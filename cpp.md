# C++面试问题

### C++基础

###### • 变长结构体(柔性数组)

###### • 拷贝构造函数为什么传引用

###### • C++ STL 的两级空间配置器

###### • sizeof

char:1  short：2  int:4  float:4  double:8  long:4(32)  8(L64/W32)  long long:8    str[]="" sizeof(str) = 1,strlen(str)=0, char *p=str, sizeof(p) = 4(指针长度)    int* m=malloc(100)，sizeof(m) = 4（指针长度）

###### • 指针和引用的区别
别名和地址(引用通过指针常量实现)、更改指向、初始化、++、sizeof、类型安全、多级、const
###### • 堆和栈的区别
进程内存分布(低到高：代码、已初始化、未初始化、堆、共享库/映射、栈、命令行参数、环境变量、内核空间)、分配和释放方式、申请后的响应(直接 vs brk/mmap)、申请效率、存储内容(堆栈不包括static变量)、大小
###### • new和delete是如何实现的，new 与 malloc的异同处
| 实现  |      |
| ---- | ---- |
| 简单类型|operator new(调用了malloc),抛出异常，可以设置new_handler不抛出异常,或者std::nothrow(？)|
| 复杂数据类型 | 算大小，先operator new再构造，先析构再operator delete |
| 数组new [ ] 与 delete [ ] | 先计算大小，再operator new，new数组会存储其大小 |

new 与 malloc 异同：
底层实现：使用operator new 调用了 malloc，malloc采用ptmalloc实现检查堆区维持的chunk和bins链表，或者用 brk/sbrk 或 mmap 映射内存，new比malloc多了一个引发异常bad_malloc和对对象进行构造
区别：关键字和库函数、参数、返回类型、分配失败、自定义类型、重载、位置(自由存储区 ≠ 堆？)

###### • C和C++的区别
面向对象、模板、重载(C++函数编译后符号表名字带参数类型)、引用、...
###### • C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）

语言特性：面向对象对于多态的处理，c++声明了virtual才多态，Java默认多态
垃圾回收：C++：RAII，智能指针，程序员负责，类型萃取      Java：自动OC机制(可达性分析)、注解、反射

###### • Struct和class的区别

strutc默认公有继承、class默认私有继承

###### • struct和union字节对齐

1.第一个从从结构体首地址offset为0的地址开始，之后的每个数据成员从自身所占字节数的整数倍开始；
2.结构体里面有结构体的，里面的成员结构体要从其它成员的最大字节数的整数倍地址开始存放；
3.结构体总的大小必须是内部最大成员的整数倍。
union:
1.union所用的实际空间为其最长成员所占的存储空间；
2.若该实际空间长度对其它元数据成员不能整除，则该空间延伸成为其整数倍。

###### • define 和const的区别（编译阶段、安全性、内存占用等）
作用阶段、拷贝数(define预编译是替换&多份拷贝、const只有一份拷贝（在符号表中）)、const有数据类型检查、可否调试
###### • 在C++中const和static的用法（定义，用途）

static：只有一份(共享一份)位于全局变量区，(全局或局部)运行完不回收，static函数避免压栈出栈，当前文件内访问，static成员函数只能操作static变量，类的对象间共享（static在C和C++中的区别主要是类的）
const：常量、防止更改，修饰形参，修饰类成员函数、成员变量、在符号表中(编译器常量)节省空间、提升效率，用于函数重载

###### • const和static在类中使用的注意事项（定义、初始化和使用）

都不能在类内初始化、const设置只读（不可修改）、static限定作用域（模块内、模块内可调用）
class Test { 
public:
       Test():a(0){}
       enum {size1=100,size2=200};
private:
       const int a;   //只能在构造函数初始化列表中初始化
       static int b;   //在类的实现文件中定义并初始化
       const static int c;    //与 static const int c;相同。
 };  
int Test::b=0;   //  static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。
cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符。但要加cosnt

###### • C++中的const类成员函数（用法和意义），以及和非const成员函数的区别
类的成员函数后面加const表明不会对这个类对象的数据成员(除了mutable成员)作任何改变。
###### • C++的顶层const和底层const 

顶层const：指针本身的值不改变，指向的永远是同一个变量；底层const：指向的变量是个常量
    int i = 0;
​    int \*const p1 = &i     //不能改变p1指针存的地址，顶层const
​    const int ci = 42;    //常量不能改变，也算是顶层const
​    const int \*p2 = &ci;    //p2存的地址可以改变，但p2解引用后得到const int，不能改变，底层const
​    const int \*const p3 = p2;    //分析p3类型，*const说明是顶层const，const int说明是底层const
​    p2 = p3;

###### • final和override关键字
final可以禁用继承和重写、override可以检测是否重写
###### • 拷贝初始化和直接初始化，初始化和赋值的区别
拷贝初始化：就是(若形参不为一个同类型的对象时先创建临时对象再)拷贝构造，但编译器常常也会优化掉创建临时变量的一步
直接初始化：直接调用构造函数
拷贝构造初始化一般发生在以一个值传递的方式传一个对象到函数中时
初始化发生在编译时、赋值发生在运行时(?)

###### • extern "C"的用法
用于c++与C混编，
(可)在C++头文件中使用
编译后C的函数名不带参，而C++由于重载是带参的

###### • 左值和右值，左值引用和右值引用（完美转发）

左值：变量等可赋值的、在内存中有确切位置的对象
右值：临时值(纯右值)、将亡值(被std::move盗取)
左值引用：对左值的引用 类型+&
右值引用：对右值的引用 类型+&&
完美转发：模板等需要二次转发时，无法保证原有值的左右值语义(因为在函数内有名字认为是左值)

###### • 模板函数和模板类的特例化
template<class T>
class Test { } 

template<>
class Test<int>{ }

###### • C++的STL源码（这个系列也很重要，建议侯捷老师的STL源码剖析书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）
###### • STL源码中的hashtable的实现
对key做hash，hash值做为存放在一个数组里的地址（使用名为hash faction的散列函数来定义有名项与存储地址之间的映射关系），当数组里的元素发生冲突时，在冲突处使用(开)拉链法
c++/go:取余hash   Java/python：高n位与低n位位异或再与2的m次方-1作与运算
c++：素数扩展    java：2的m次方
c++：开链法   Java：开链法+超过8变红黑树   python：二次哈希

###### • STL中unordered_map和map的区别和应用场景
unordered_map使用哈希表，而map使用红黑树
红黑树：二叉，节点红or黑
根为黑
每个叶节点为黑
红的子必须为黑
从一个到子孙节点的所有路径上包含相同节点的黑数目
unordered_map适用于访问，数据量小，map适用于数据量大和顺序有关的

###### • STL中vector的实现
###### • STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器forward_list，双向迭代器，随机访问迭代器）

迭代器适配器

###### • STL中的traits技法
萃取机制解决模板参数类型推断时无法推断返回类型的问题，于是对iterator引入了五种特性用以获取iterator的特性，而对于指针，则使用模板偏特化实现
###### • vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。
空间不足需要扩容(1.5或2倍扩容)，扩容过程中涉及旧数组向新数组的拷贝
###### • C++中的重载和重写/覆盖的区别？隐藏呢？
编译时多态、运行时多态（重载时在编译器就带了参数类型）override（重写）
　　 1、方法名、参数、返回值相同。
　　 2、子类方法不能缩小父类方法的访问权限。
　　 3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
　　 4、存在于父类和子类之间。
　　 5、方法被定义为final不能被重写。
　overload（重载）
　　1、参数类型、个数、顺序至少有一个不相同。 
　　2、不能重载只有返回值不同的方法名。
　　3、存在于父类和子类、同类中。

###### • C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解
###### • 介绍面向对象的三大特性，并且举例说明每一个
封装：private  多态：虚函数  继承：父子
###### • C++多态的实现
虚函数、虚函数表
###### • C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，因为调用的时候会传this指针，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间：对象创建时初始化，对象创建完成时确定指向，因为子类对象创建时先调用父类构造函数，虚指针指向父类虚表）
虚函数表属于类，虚函数表指针属于对象，单继承时先复制父类的虚表，然后再在其基础上修改增加，多继承时会分别复制两个父类的虚表，维持两个虚表指针(虚继承通过别的虚表指针实现间接基类只一份)；虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。虚表指针在构造函数调用前（与初始化列表一样），虚表的创建是在编译期。
###### • C++中类的数据成员和成员函数内存分布情况
成员变量属于对象，成员函数属于类   成员函数和全局函数一样，只是在编译时传入了对象的指针
###### • this指针
不占用内存，只能用于非静态成员函数，在调用成员函数时创建，成员函数调用结束时销毁，this指针生命周期时可能只存在于寄存器
###### • 析构函数一般写成虚函数的原因
创建指针对象后(多态调用时)，delete释放资源，可以既调用子类析构，又调用父类析构
###### • 构造函数、拷贝构造函数和赋值操作符的区别
拷贝构造是对象还未创建时调用，对象已创建之后再给对象传值调用的是'='运算符
###### • 构造函数声明为explicit
explicit关键字的作用就是防止类构造函数的隐式自动转换；在没有explicit时是通过隐式转换调用有参构造创建的
###### • 构造函数为什么一般不定义为虚函数
因为是没有意义的，虚函数是为了实现多态，而构造函数不能直接调用，因此没必要实现多态  虚函数始终仅仅调用基类的虚函数
###### • 构造函数的几种关键字(default delete 0)
default表示使用默认构造函数，delete表示不让编译器生成默认构造函数，0是用于声明纯虚函数的
###### • 构造函数或者析构函数中调用虚函数会怎样
因为构造派生类要先调用基类构造，基类构造中调用虚函数体现出的是基类特性，与多态性不符（语法上没有错） 创建子类对象时，先调父类构造，父类构造调用虚函数是父类的虚函数，只有普通成员函数调用虚函数能够实现多态
###### • 纯虚函数
virtual void funtion()=0;
###### • 静态类型和动态类型，静态绑定和动态绑定的介绍
静态类型就是父类指针类型，动态类型是指父类指针指向的子类对象的类型
表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；
而动态类型则是变量或者表达式表示的内存中的对象的类型，动态类型直到运行时才可知。
（Java的反射是当派生类添加了基类中没有的方法时，基类引用/指针无法调用这个新添加的方法而产生的？）

###### • 引用是否能实现动态绑定，为什么引用可以实现
引用通过指针常量实现，实际上是编译器进行了地址的传递，因此可以
###### • 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）
浅：两个对象指向同一地址；深：指向不同地址  默认拷贝函数是浅拷贝，析构时两次析构，会有内存泄露
###### • 对象复用的了解，零拷贝的了解 
对象复用（对象池）
零拷贝：sendfile，splice，tee，mmap，避免在内核区和用户区不必要的拷贝

###### • 介绍C++所有的构造函数
默认构造函数、一般构造函数、拷贝构造函数，移动构造函数
###### • 什么情况下会调用拷贝构造函数（三种情况）
classname newobj(obj);  由实参到形参值传递时拷贝构造;  classname newobj=fun()，这里fun()返回值为一个对象
###### • 结构体内存对齐方式和为什么要进行内存对齐？
对齐方式与变量的顺序有关，前一大于后一时直接加，后一大于前N时，相加并扩为后一的整数倍  原因：设备原因（不是所有设备都能访问所有内存）效率原因（未对齐的内存需要访问两次）
###### • 内存泄露的定义，如何检测与避免？
程序未能释放掉不再使用的内存的情况  使用BoundChecker或valgrind检测，使用智能指针来避免
gdb调试原理：ptrace

###### • 手写智能指针的实现（shared_ptr和weak_ptr实现的区别） 
###### • 智能指针的循环引用
导致内存泄漏，通过将任一shared_ptr改为weak_ptr即可解决
###### • 遇到coredump要怎么调试
gdb [exec file] [corefile]
###### • 内存检查工具的了解
valgrind
###### • 模板的用法与适用场景
###### • 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？
少了一次调用默认构造函数的过程
###### • 用过C++ 11吗，知道C++ 11哪些新特性？
迭代器、auto、nullptr、智能指针、委托构造、继承构造、Lambda表达式、强制类型转换
###### • C++的调用惯例（简单一点C++函数调用的压栈过程）
main函数参数、返回地址入栈，位于栈底，遇到函数先压入函数的参数和返回地址，然后再将函数局部变量入栈，函数运行结束，eax寄存器保存返回值，函数出栈，main结束，main出栈
###### • C++的四种强制转换
1、static_cast没有运行时类型检查来保证转换的安全性，2、const_cast能将 const int* 转成 int*，3、reinterpret_cast可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针，4、dynamic_cast运行时处理的，运行时要进行类型检查

###### • C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）
###### • C++的异常处理
try{}catch(...){}   throw
###### • volatile关键字
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问
###### • 优化程序的几种方法
掌握常用的高效的数据结构和算法\尽量减少循环次数\消除不必要的存储器引用\提高并行性\多线程编程
###### • public，protected和private访问权限和继承        
private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问
public继承：public继承后，从父类继承来的函数属性不变（private、public、protected属性不变，）。
private继承：private继承后，从父类继承来的函数属性都变为private
protected继承：protected继承后，从父类继承过来的函数，public、protected属性变为protected，private还是private(从父类继承的private成员不能被自己直接访问)

###### • class和struct的区别
struct公有继承、class私有继承
###### • decltype()和auto
decltype()推导类型并定义 int a; decltype(a) x;定义了a同类型的x
对于引用类型的变量，auto 推出引用变量所指向的变量类型，decltype 推出引用变量本身的类型；
auto 会忽略顶层 const，decltype不会；
decltype((variable)) 推出该变量的引用类型

###### • inline和宏定义的区别
（1）内联函数在编译时展开，宏在预处理时展开；
（2）内联函数直接嵌入到目标代码中，宏是简单的做文本替换；
（3）内联函数有类型检测、语法判断等功能，而宏没有；
（4）inline函数是函数，宏不是；
（5）宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；

###### • C++和C的类型安全
（1）操作符new返回的指针类型严格与对象匹配，而不是void*；
（2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
（3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
（4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
（5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

###### • array[5]={1,2,3,4,5}，(array+1)和(&array+1)?

*(array+1)中是数组首地址+1，(&array+1)是数组地址+1，+1后=(array+5(数组长度) )


### 操作系统基础

###### • 进程与线程的区别和联系
资源分配，CPU调度；堆，栈；一个进程包含多个线程；数据共享难、易；资源消耗多、少；线程在执行过程中，需要协作同步
线程共享的堆、地址空间、全局变量、打开的文件、子进程、信号处理器、当前目录和用户          不共享：线程ID，寄存器组值、栈、信号掩码、错误返回码

###### • 一个进程可以创建多少线程，和什么有关
和用户可以使用的内存大小和线程栈所占内存(1M)有关
linux下300？8M

###### • 一个程序从开始运行到结束的完整过程（四个过程）
预处理（.i，头文件编译进来，宏替换），编译（.s，各种分析后汇编语言），汇编（.o），链接（模块间，动态 静态）
###### • 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）
Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字（socket）
Linux线程间通信：互斥量（mutex）,信号量，条件变量
Windows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字（socket）
Windowst线程间通信：互斥量（mutex）,信号量（semaphore）、临界区（critical section）、事件（event）

###### • 文件读写使用的系统调用
open，close，creat，read，write
###### • 怎么回收线程        
linux线程执行，pthread有两种状态joinable状态和unjoinable状态
线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当调用了pthread_join之后这些资源才会被释放。
若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。

###### • 守护进程、僵尸进程和孤儿进程 
守（独立于控制终端的程序）僵（子进程结束但父进程未调用wait|waitid导致子进程信息不被释放）孤（子进程的父进程结束，子被Init进程收留）
###### • 处理僵尸进程的两种经典方法
父进程回收法（父进程调用wait方法使父进程阻塞直到子进程结束运行）init进程回收法（init的子进程结束会自动回收其子进程）信号signal忽略 或者信号机制调用wait/waitpid
###### • 进程终止的几种方式
正常退出（调用return、_exit、exit）、异常退出（调用abort退出、外部信号强制退出ctrl+c）
###### • linux中异常和中断的区别
中断是由硬件产生的，交由CPU处理，CPU交由内核处理；异常由CPU产生，交由内核处理；     使用不同的处理程序
###### • 一般情况下在Linux/windows平台下栈空间的大小
L8M W1M
###### • 五种IO模型
阻塞、非阻塞、信号驱动、多路复用、异步
###### • 程序从堆中动态分配内存时，虚拟内存上怎么操作的        
###### • 交换空间与虚拟内存的关系
虚拟内存是一项技术，包括交换空间、页面置换调度等，逻辑空间与物理空间分离
###### • 堆和栈的区别；从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）
栈上分配是直接分配，堆上要先在空闲链表内找最佳匹配、首次匹配或最差匹配
###### • 内存泄漏和内存溢出
泄漏：程序结束时无法释放内存   溢出：剩余的内存不够申请
###### • 常见内存分配方式和错误 
静态存储区分配、栈区分配、堆区分配     问题：未分配就使用、未初始化就引用、忘记释放、释放后还使用、数组越界
###### • 堆内存和栈内存的区别
分配释放方式、存储的内容
###### • 可重入函数和可重入内核
可重入函数是指在任何时候都可以中断并转而去执行其他任务，返回后没有问题； 内核都是可重入的
###### • 操作系统动态内存分配的几种策略
首次适应法（最快）、最佳适应法（碎片最小）、最差适应法
###### • 内部碎片和外部碎片
为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。
为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。

###### • 系统调用进入内核态的过程
应用程序调用系统调用API，存入系统调用号，触发0x80中断，进入中断服务程序，根据调用号调用系统调用 返回 中服 返回 API 返回 应用程序
###### • 内核态和用户态的区别
内核态位于0级特权环（R0），可以访问所有的内存空间和对象，所占用的处理器不能被抢占；用户态位于3级特权环（R3），进程可以访问的内存空间和对象受限，处理器可以被抢占
###### • 常见的进程调度算法以及linux的进程调度
时间片轮转、先来先服务、短作业优先、最高相响应比优先、优先级调度、多级反馈调度
linux采用CFS完全公平调度

###### • 中断、陷阱、故障和终止
中：硬件导致、异步   陷阱：执行语句的结果(故意引起)、同步异常   故障：错误引起，若被修正则正常执行，否则abort()   终止：致命错误、直接abort()
###### • 线程互斥和同步的方法
互斥变量(互斥锁)、信号量、条件变量、读写锁
###### • 内存对齐的规则和作用
对齐方式与变量的顺序有关，前一大于后一时直接加，后一大于前N时，相加并扩为后一的整数倍  原因：设备原因（不是说有设备都能访问所有内存）效率原因（未对齐的内存需要访问两次）
###### • 页面置换算法
最佳置换（OPT）算法、先进先出置换（FIFO）算法、最近最久未使用（LRU）算法、时钟Clock、增强Clock
###### • 实现一个LRU页置换算法（或者FIFO置换算法）
###### • 死锁的必要条件（怎么检测死锁，解决死锁问题）,银行家算法（死锁避免）
循环等待、不可剥夺、请求与保持、互斥
###### • 哲学家就餐，读者写者，生产者消费者（怎么加锁解锁，伪代码）        
###### • 海量数据的bitmap使用原理
redis bitmap setbit getbit...
###### • 布隆过滤器原理与优点
使用几个hash函数对数据进行映射，最后通过对需要查询的数据进行hash来看map是否置1来确定一定不存在和可能存在
###### • 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题




### 网络基础
###### • 网络的几种分层体系结构
OSI（应、表、会、传、网、数、物）TCP\IP(应、传、网、网接)  五层（应、传、网、数、物）
###### • 建立TCP服务器的各个系统调用
socket() bind() listen() connect() accept() send() recv() shutdown()
###### • socket网络编程close是一次就能直接关闭的吗，半关闭状态是怎么产生的？
由于可能有很多连接，因此只是引用计数减一而不是直接关闭；半关闭状态是client发送FIN后需要server的ACK，此时只能接收不能发送
###### • MTU和MSS        
MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。
MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。

###### • 对路由协议的了解与介绍        
###### • 路由协议所使用的算法

RIP，OSPF，BGP

###### • 路由表的项目包括哪些

前缀(目的网段)、掩码、下一跳、开销、优先级、输出接口

###### • 地址解析协议ARP的过程

主机广播arp询问ip为。。是谁，从收到arp返mac地址，主机ping从机，从机收到icmp广播arp询问主机的mac

###### • 网际控制报文协议ICMP的过程

###### • 动态主机配置协议DHCP的过程 

diiscover  offer  request  request(renew)  ack(renew)

###### • WAN LAN WLAN VLAN VPN的区别        
###### • 介绍一下VPN（虚拟专用网）        
###### • TCP和UDP的区别
TCP 流、可靠、头部20、面向连接、开销大、拥塞控制流量控制   UDP 数据报、不可靠、头部8、无连接、开销小、无拥塞流量控制
###### • TCP如何保证数据的正确性
确认重传、流量控制、拥塞控制、分片和排序、通过循环冗余校验CRC校验数据
###### • TCP和UDP相关的协议与端口号
TCP(http80\https443\smtp25)   UDP(DNS53\DHCP67)
###### • TCP（UDP，IP）等首部的认识（http请求报文构成）
http：请求行（请求方法、URL、协议版本）、请求头、请求体
###### • 网络层分片的原因与具体实现
因为链路层的最大传输单元MTU限制了传输数据的大小
###### • TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）

###### • TCP握手以及每一次握手客户端和服务器端处于哪个状态（11种状态）
SYN_SEND SYN_RECV ESTABLISHED FIN_WAIT1 FIN_WAIT2 CLOSE_WAIT LAST_ACK TIME_WAIT 
###### • 为什么使用三次握手，两次握手可不可以？
两次握手可能导致服务端收到过期的客户端请求，从而占用资源等待客户端发送数据
###### • TIME_WAIT的意义（为什么要等于2MSL）
防止客户端ACK未到达服务端，服务端可以重发FIN；防止过时的ACK到达服务端；MSL是最大存活时间，FIN+ACK为2MSL
###### • 超时重传机制（不太高频）
发送后定时，未收到ACK重传
###### • TCP怎么保证可靠性（面向字节流，超时重传，应答机制，滑动窗口，拥塞控制，校验等）？        
###### • 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？        
###### • TCP滑动窗口协议 
窗口包含（已发未收ACK，已读入内存未发送）
###### • 拥塞控制和流量控制的区别
拥控是为了防止过多数据注入网络使网络中的路由器或链路不致过载；流控是解决发送接收不同步的问题
###### • TCP拥塞控制，算法名字？（极其重要）
慢启动(接收方每次收到才上一次2倍发ack)、拥塞避免（线性加一）、快速恢复(3个重复确认，就降低慢开始门限到一半然后拥塞避免)、快速重传(接收方立即确认，失序也确认，3个连续重复确认立即重传)
###### • 网页解析的过程与实现方法

dns tcp http dom树 异步请求 js阻塞

###### • 应用层协议常用的端口号
http80 https443 ssh22 telnet23 smtp25 dns53 ftp20\21
###### • http协议与TCP联系 
http是应用层协议，定义的是传输数据的内容规范；TCP是传输层协议，定义的是传输数据和建立连接的规范；HTTP是使用TCP进行数据传输的
###### • http/1.0和http/1.1的区别
1.0不默认长连接，缓存处理，返回部分信息(range头域)，错误码新增，Host头域

###### • http的请求方法有哪些？get和post的区别。
head，options，get，post，put，delete，trace，connect
get请求资源 post上传或更新资源         参数位置、参数大小、服务器接收次数、适用场景

###### • http的状态码
200OK 400请求语句错误、403拒绝服务、404找不到资源、500服务器错误、503一段时间后恢复服务

###### • http和https的区别，由http升级为https需要做哪些操作
http安装SSL证书后就成了https
SSL/TLS:
1.浏览器向服务端发自己支持的加密协议
2.服务端选一个加密协议
3.客户端用CA的公钥验证服务器，并用服务器公钥生成随机数加密
4.服务器接收到后也获得会话密钥

###### • https的具体实现，怎么确保安全性
###### • 在浏览器输入一个URL的流程，这个过程中浏览器做了什么（如www.baidu.com）        
###### • URL包括哪三个部分？

协议、ip、文件路径

###### • 长连接与短连接的区别以及使用场景
长连接是在server响应之后不断开连接，用于操作频繁、点对点通信；短连接一般用于WEB的http服务
###### • 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？

65535，不可改变    会减到65535个

###### • 介绍一下ping的过程，分别用到了哪些协议
IP封装ICMP包，使用ARP查找目标mac地址，发送ICMP包，目标收到返回ICMP包
###### • 对称密码和非对称密码体系
对称：相同的密钥加密解密；非对称：不同的密钥加密和解密
###### • 数字证书的了解（高频）
证书可以确保证书里的公钥确实是证书所有者的，证书内包含（颁发机构、公钥、有效期、签名算法、持有者）
###### • 客户端为什么信任第三方证书
因为通常第三方证书的颁发机构是足够权威的，所提供的根证书已经添加进了证书列表里(第三方证书机构可以由自己的上一级证书服务器证明自己是可信的)
###### • RSA加密算法（非对称加密，用公匙和私匙实现）;
RSA是基于大数很难做质因子分解而进行的非对称加密
###### • MD5原理（MD5是密码散列函数）=> SHA安全散列算法替代
MD5将明文内容按某种规则生成一段hash值，只要明文内容稍有改变，hash值都会完全不同
MD5会减损信息，所以不能倒解

###### • 单条记录高并发访问的优化        
###### • 数据流和粘包问题 

 定长/发送时分包不满缓冲就发；应用层协议告诉数目；特殊结束符

###### • 一台机器最多可以建立多少tcp连接？
180000

###### • 五种IO模型的过程和比较
阻塞、非阻塞、信号驱动、多路复用、异步
###### • IO多路复用（select，poll，epoll的区别）        
select    轮询    fd_set    需要每次将fd拷贝进内存     少量fd且活跃    fd最多1024
poll      轮询    fd链表    需要每次将fd拷贝进内存     少量fd且活跃    fd无限制
epoll     信号    fd_ctl    共享内存                  大量fd不活跃    fd无限制

###### • 有没有抓过TCP包，描述一下
wireshark选网卡，过滤TCP
tcpdump

###### • 一个ip配置多个域名，靠什么识别？
端口、虚拟主机
###### • 服务器攻击（DDos攻击）        
###### • 重放攻击，IP欺骗 
Linux相关
###### • Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）        
###### • 文件系统的理解（EXT4，XFS，BTRFS）        
###### • 文件处理grep,awk,sed这三个命令必知必会        
###### • IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？
###### • Epoll的ET模式和LT模式（ET的非阻塞）
LT水平触发（默认）通知的事件未处理下次还会通知；ET边缘触发，通知的事件不处理，直接移除等待队列，下次自然不在通知；ET效率更高
##### • 查询进程占用CPU的命令（注意要了解到used，buf，***代表意义）        
###### • linux的其他常见命令（kill，find，cp等等）        
###### • shell脚本用法        
###### • 硬连接和软连接的区别
硬链接：两个文件指向同一磁盘空间  ln file1 file2  给file1创建硬链接
软连接：文件2指向文件1，文件1指向磁盘空间，类似快捷方式 ln -s file1 file2

###### • 文件权限怎么看（rwx）        ll显示当前目录的详细信息
###### • 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变
atime只要访问就改变  ctime只要修改里面的内容就改变  mtime修改文件属性（权限之类）就会改变
###### • Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令
ifstat  nethogs


### 数据库基础        
###### • 关系型和非关系型数据库的区别（各自优点）
关系型技术成熟，只支持基本数据类的查询，数据存放在硬盘上，查询速度慢，收费            非关系型技术较新，学习资料少，数据存放在缓存中，查询速度快，开源
###### • 常用SQL语句

（DDL,DML,DCL,TCL）        

###### • 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写        
###### • 数据库的索引类型
普通索引、唯一索引、主键索引、复合索引、全文索引
###### • 聚集索引和非聚集索引的区别（叶节点存储内容）        
像InnoDB这种将索引和数据存放在一起（一个.ibd文件中）的主键索引就是聚集索引        InnoDB叶子节点存储的是数据
像MyISAM这种将索引和数据分开存放（.MYI和.MYD）的主键索引就是非聚集索引           MyISAM叶子节点存储的是索引

###### • 唯一性索引和主码索引的区别 
主键索引是一种特殊的唯一索引，一个表只有一个主键，一般在建表时创建主键索引
###### • 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）        
1. 优点：
    通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。
    可以加快数据的检索速度
    可以加速表与表之间的连接
    在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间
2. 缺点
    创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
    索引需要占用物理空间，数据量越大，占用空间越大
    会降低表的增删改的效率，因为每次增删改索引，都需要进行动态维护
3. 什么时候需要创建索引
    * 主键自动建立唯一索引
    * 频繁作为查询条件的字段应该创建索引
    * 查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找
    * 查询中统计或者分组的字段；
###### • 索引的底层实现（B+树，为何不采用红黑树，B树）        
###### • B树和B+树具体实现
B树在每个节点下面都存数据 B+树只有叶子节点下面存放数据
###### • 索引最左前缀问题 
如果在a、b、c列上建立了组合索引，使用索引进行查询时，a|a,b|a,b,c 这3种情况是会用到每一列的索引的，而b,c|c是不会用到索引的，这就是最左前缀原则，此外如果是a,c只有a会用到索引
###### • Mysql的优化（高频，索引优化，性能优化）

回表查询

###### • 数据库引擎介绍，Innodb和Myisam的特点与区别 
Innodb为聚合索引，查询效率高于Myisam非聚合索引；InnoDB支持事务，MyISAM不支持；InnoDB支持外键，而MyISAM不支持
###### • 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）
ACID原子、一致、隔离、持久

###### • 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）
不可：updata+commit 幻读：insert+commit 丢失修该:A=100,事务1A-30,事务2A=10，结果是90，也就是事务2的操作使事务1的值丢失
###### • 数据库的隔离级别，Mysql和Oracle的隔离级别分别是什么
RU读未提交 RC读已提交 RR可重复读 Serializable可串行化
###### • 数据库连接池的作用
用户房访问网站的数据库需要建立连接，用完后释放；但是当有很多用户访问时，效率降低，因此，在用户访问数据库前，创建连接池提前准备好连接，不同用户访问数据库直接从连接池获取连接，用完还给连接池
###### • Mysql的表空间方式，各自特点
独立表空间、共享表空间   独立：每个表有自己的表空间、数据索引放在自己的表空间内、可以实现数据库间的移动     共享：可以将表空间拆分为多个文件存放在磁盘上
###### • 分布式事务        
###### • 数据库的范式 
一范式，看是否满足原子性，满足则是（一个字段下不能有其它字段） 二范式看是否存在部分函数依赖，存在则不是（如果存在重复字段却能用一个字段来确定）  三范式看是否存在传递函数依赖（A->B,B->C则A->C）
###### • 数据的锁的种类，加锁的方式 
共享锁(Shared lock)    A和B可以对同一资源加共享锁，且都可以读，但不能写，任意一方想加排他锁，必须等另一方释放该锁
排它锁(Exclusive Locks)    A和B任一方加排他锁，另一方都不能再对该资源加锁
临键锁(Next-Key Locks)    RR可以理解为一种特殊的间隙锁，也只能对非唯一索引加锁，锁住的是当前键开始到下一键值的左开右闭区间，加锁后其他事务无法在这个区间插入数据，解决了幻读问题
间隙锁(Gap Locks)    RR只能对非唯一索引加锁，条件里有范围，另外需要确保执行该语句时，explain种确实走了索引
自增锁(Auto-inc Locks)    表级别锁，专门针对事务插入AUTO_INCREMENT类型的列。如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行是连续的主键值。
计划锁(Schema Locks)    该锁不允许任何其它session连接该表。连都连不了这个表了，当然更不用说想对该表执行什么sql语句了
意向锁(Intent Locks)    表级锁，当表内有资源加锁，不需要访问表内去看，直接看是否加了表锁
更新锁(Update lock)    为了解决死锁，引入了更新锁，当A加了更新锁，B就不能加锁并阻塞，当其他用户尝试加锁并不会阻塞而是直接返回“我现在只想读，你们别人也可以读，但我将来可能会做更新操作，我已经获取了从共享锁（用来读）到排他锁（用来更新）的资格”

###### • 事务：单一逻辑工作单元的集合
###### • 视图的作用与使用方法（如何删除等）
视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。creat view v_t as select * from table1 where id>1 and id<5; Drop view
###### • 分库分表，主从复制，读写分离。（我不会，也没碰到过）        
###### • 项目中哪里用到了数据库，怎么用的        
###### • Memcached和Redis了解



#### • 服务器设计

##### linux高性能服务器编程(游双)：

###### • 高性能1：socket选项设置

so_reuseaddr（使得新连接能使用处于time_wait状态的连接）和修改tcp_tw_recycle（快速回收：使得连接不要处于time_wait状态就关闭）
so_rcvbuf 和 re_sndbuf 修改tcp缓冲区大小
so_rcvlowat 和 so_sndlowat 低水位标记：只有缓冲区的数据大于或者小于该设置时，才被select、poll、epoll等认为可读/可写
so_linger 可以设置关闭时是1.发送完缓冲区数据再关闭或者2.立即关闭或者3.对于阻塞IO等待一段时间或发送完关闭，非阻塞IO立马关闭

###### • 高性能2：零拷贝/映射同一块儿缓冲区/减少系统调用

dup 和 dup2 函数
writev 和 readv
sendfile 
mmap 与 munmap
splice 函数与 tee 函数

###### • 服务器模型：Reactor 与 Proactor

###### • 服务器并发模型：半同步/半异步 与 领导者/追随者

###### • http协议：有限状态机

###### • 高性能3：池、减少数据复制(C++移动语义)、上下文切换和锁(减少上下文切换、减少锁争用)

###### • 高性能4：IO多路复用 select、poll和epoll

###### • 设计规范：统一事件源，将信号用管道封装，然后加入到 select 监听（统一事件处理器）

###### • 设计技巧：用定时器处理非活动连接（基于升序链表的定时器、基于高性能时间轮的定时器、基于时间堆的定时器）

##### Linux多线程服务端编程：使用muduo C++网络库

###### • 多线程设计技巧：用智能指针 shared_ptr 和 weak_ptr 来管理线程安全的对象生命周期

###### • 多线程同步设计：使用非递归mutex，条件变量，countdownlatch，避免使用信号量、读写锁，pthread_once 实现单例模式，shared_ptr 实现的copy-on-write

###### • 服务器模型选择：进程间尽量用tcp连接通信，单进程单线程、多进程单线程、单进程多线程、多进程多线程，11种并发服务器方案

###### • 多线程设计注意：pthread_cancel危险、exit(3)危险、__thread线程独有变量(c++中的threadlocal)、RAII包装文件描述符、多线程与fork(危险)、多线程与signal（避免）

###### • 多线程日志方案：双缓冲日志设计

###### • 应用示例设计

聊天室编解码器设计；
muduo的应用层buffer；
基于Google Protobuf的(分布式)网络传输(Protobuf编解码器，基于多态模板的消息分发器)；
限制并发连接数、定时器timefd、测RTT和clock offset，使用timing wheel 时间轮踢掉空闲连接；
简单广播、多线程广播Hub设计；
串并转换multiplexer，socks4a代理服务，短址服务；
DNS服务，与UDNS、c-ares DNS、curl 服务配合

###### • muduo网络库

###### • 分布式

可靠性、负载均衡、心跳协议、分布式系统进程标识、易于维护的分布式系统(留系统探查接口)、为系统热演化做准备、自动化回归测试、分布式部署监控管理层次

###### • C++编译链接模型

C编译模型、C++编译模型(单遍编译、前向声明)、C++链接(重载、内联、模板、虚函数)、头文件规则、库文件组织原则(动态库、静态库、源码编译)

##### • 反思C++对象模型与虚函数

C++的二进制兼容性问题、避免使用虚函数作为库接口、推荐接口设计(pimpl、function/bind)、iostream用途局限、值语义与数据抽象(ADT)

###### • C++经验谈

异或交换变量不提倡(写规范的编译器易优化的代码)、不要重载全局operator new、带符号的除法与余数、单元测试中mock、慎用匿名namespace、采用有利于版本管理的代码格式、string (eager copy、copy on write、SSO)、algorithm算法的几个应用

#### 大数据和分布式
###### • Hadoop框架下，各个组件的构成及作用

HDFS(分布式文件系统)、MapReduce(分布式计算框架)、Yarn(分布式任务协调系统)

###### • BASE原则，CAP原则

CAP原则：Consistency(一致性)、Availability(可用性)、Partition tolerance(分区容错性)，在分布式系统中只能满足其中两个
BASE原则：Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）

###### • 一致性算法Raft的过程

选举过程
状态复制过程

###### • TIDB原理 

分布式数据库，NewSQL

###### • HBase的存储原理 

 基于HDFS的分布式非关系型数据库
• HDFS运行原理
• Hive的了解(数据仓库)
• Spark的了解 (分布式计算引擎)

#### 设计模式

###### • 介绍熟悉的设计模式（单例，简单工厂，观察者模式等等）
1.创建型：
+简单工厂：简单工厂+抽象产品父类+具体产品子类                                                           用于创建对象  eg.几个不同类型产品
+工厂方法：抽象工厂父类+具体工厂子类+抽象产品父类+具体产品子类                     用于创建对象，业务可能有增加新产品的可能  eg.不同产品，可能增加新产品
+抽象工厂：抽象工厂父类+具体工厂子类+(多个)抽象产品父类+具体产品子类                  用于创建对象，可能有新厂家和新产品类型  eg.可能有二维业务扩展方向
+单例模式：单例类+访问类                                                                    用于保证程序中只存在一份实例，eg.线程池
+原型模式：抽象原型类+具体原型类+访问类                                                 用于快速复制，修改属性不多   eg.一个对象，只修改一两个参数
建造者模式：产品+抽象建造者+具体建造者+指挥者                                    用于创建一个由多个对象聚合到一起的对象   eg.一个对象可能由其它多个对象装配
2.结构型：
+代理模式：抽象主题+具体主题+代理类                              用于控制访问具体主题  eg. 对原来的接口做一个控制，过滤某部分无效请求(布隆过滤器或者过滤器)
适配器模式：适配者类(要被适配的原始组件)+适配器类+目标(当前系统所期盼的接口)                老接口要适配新的业务，统一接口  eg.新业务统一接口
桥接模式：抽象化角色+扩展抽象化角色+实现化角色+具体实现化角色          用于两个维度变化的类，如不同颜色和形状的图形(将继承变组合)  eg.二维扩展的业务
装饰模式：抽象构件+具体构件+抽象装饰+具体装饰                   不改变原对象结构的情况下动态地给对象增加一些功能  eg.“变身”之后的游戏角色
外观模式：外观角色+子系统角色+客户角色                   用于统一多种不同的同类的子系统，如一个流程需要多个部门办理  eg.某个“部门”类，办手续需要多个窗口
享元模式：抽象享员角色+具体享员角色+非享员角色+享员工厂角色                  用于对象池，多个重复对象(如五子棋)使用   eg.五子棋
组合模式：抽象构件角色+树叶构件角色+树枝构件角色                        用于文件夹—文件，窗口中的简单控件与容器控件等类似的   eg.文件夹类型的这种树
3.行为型：
模板方法模式：抽象类+具体子类                     用于框架设计，或者有些行为要由具体环境决定    eg. web服务框架
+策略模式：抽象策略类+具体策略类+环境类            同一个问题环境不同可能有不同的实现策略，并且算法可能会改变  eg.可能在新地区某个操作有新的处理方式
命令模式：抽象命令类+具体命令类+实现者/接收者角色+调用者和请求者角色                     命令可能由修改或者撤销，或不在一个线程/机器上   eg.分布式调用
责任链模式：抽象处理者角色+具体处理者角色+客户类角色                         处理流程需要多个对象参与并且流程过程可能会被修改      eg.多个不同层级的鉴权
状态模式：环境角色+抽象状态角色+具体状态角色                 涉及到复杂的状态转换时，把每一个状态抽象为一个具体状态类     eg.状态机
+观察者模式：抽象主题+具体主题+抽象观察者+具体观察者                                  观察者和目标之间有一个单向的依赖关系    eg.有关于GUI的更新等
中介者模式：抽象中介者+具体中介者+抽象同事类+具体同事类                      对象之间存在着十分复杂的网状关系时   eg.公司通讯录，IM聊天室
迭代器模式：抽象聚合角色+具体聚合角色+抽象迭代器角色+具体迭代器角色                         为不同的聚合对象创建统一的遍历接口时      eg.容器的迭代器
访问者模式：抽象访问者角色+具体访问者角色+抽象元素角色+具体元素角色+对象结构角色         访问操作依赖于具体的访问角色     eg.不同的访问角色操作不同
备忘录模式：发起人角色+备忘录角色+管理者角色                              存档撤回等功能       eg.记事本回退，游戏存档
解释器模式：

###### • 写单例模式（饿汉模式和懒汉模式），线程安全版本

C++可以使用call_once 和 once_flag 实现单例模式/或者使用成员函数内static变量

• MVC设计模式


#### drogon框架

###### • trantor网络库

socket类:封装socket的创建、连接、设置等；InetAddress类：IPv4/v6地址操作以及端口操作的封装；